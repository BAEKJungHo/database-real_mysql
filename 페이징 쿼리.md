# 페이징 쿼리

MySQL 서버에서 페이징하려면 LIMIT 기능을 많이 사용한다. LIMIT 이 사용된 페이징 쿼리가 인덱스를 이용할 수 있다면 크게 성능상의 문제 없이 사용할 수 있다.
하지만 인덱스를 사용한다 하더라도 계속해서 다음 페이지로 넘어가면 조금씩 조회 쿼리가 느려질 수 밖에 없는 구조이다.

단순히 LIMIT 의 오프셋(offset) 만 변경해 다음 페이지의 레코드를 조회하는 쿼리는 실제 필요하지 않은 레코드까지 모두 읽는 방식으로 처리된다.

`예를들어 어떤 사용자가 100 페이지를 조회한다고 가정하면 이 쿼리는 LIMIT (100*20), 20 과 같은 LIMIT 절이 필요하다. 
그러면 MySQL 서버는 2000 번째 레코드부터 20 개의 레코드만 읽는것이 아니라, 첫 번째 레코드부터 2000 번째 레코드까지는 읽어서 버리고 그 위치에서 20 개의 레코드를 더 읽어서 클라이언트로 반환하는 것이다.
이 현상은 뒷 페이지로 갈 수록 심해진다.`

보통 웹 페이지에서 사용자들은 일반적으로 1 페이지에서 10 페이지 이내의 게시물만 본다. 또한 최근 스마트폰 어플리케이션은 페이지 버튼을 누르는 것이 아닌 "다음 더보기", "이전 더보기"와 같은 기능으로 구현되고 조작도 간단해서 쉽게 20~30 페이지 뒤로 이동할 수 있기 됐다.

조금만 고민해 본다면 쉽게 이런 불필요한 작업을 쉽게 제거할 수 있다. 어떻게 페이징 처리에서 불필요한 작업을 제거할 수 있을지 살펴보자.

참고로 페이징 쿼리는 InnoDB 테이블과 MyISAM 테이블에서 조금은 다른 방법으로 처리되며, 불필요한 작업을 제거하는 방법도 조금 다르다.

- 지금까지의 방법

```sql
CREATE TABLE tb_article (
  board_id int not null,
  article_id int not null auto_increment,
  article_title varchar(100) not null,
  ...
  PRIMARY KEY (article_id),
  INDEX ix_boardid (board_id, article_id)
);
```

위의 테이블은 게시판(board) 단위로 조회되는 페이징 쿼리가 많을 것으로 가정해서 board_id 에 대해서도 인덱스를 생성해 뒀다. 
애플리케이션에서는 게시판 단위로 게시물의 목록을 조호하기 위해 다음과 같은 쿼리가 사용될 것이다.

```sql
SELECT * 
FROM tb_article WHERE board_id = 1
ORDER BY article_id DESC LIMIT n, m
```

여기서 n 값은 게시판에서 첫 번째 페이지에서 두 번째 페이지로, 그리고 세 번째 페이지로 이동할 때마다 페이지당 게시물 건수만큼 증가할 것이다.

이 쿼리에서와 같이 WHERE 조건이 인덱스의 컬럼만으로 처리(`커버링 인덱스`)될 수 있다면 그나마 다행이다. 하지만 페이징 쿼리가 커버링 인덱스로 처리되지 못한다면 이 쿼리는 쓸모없는 70건의 레코드에 대해 데이터 파일까지 읽어야 한다. 

## 불필요한 접근을 제거하기 위한 페이징 쿼리

페이징 쿼리에서 지금까지 살펴본 불필요한 작업을 제거하려면 다음과 같이 하면된다. 제약 조건이 조금 있지만 해결 방법은 의외로 간단하다. 

`페이징 쿼리를 실행할 때 게시물 테이블의 PRIMARY KEY 인 article_id 를 SELECT 쿼리의 조건절에 넣어주기만 하면 된다.`

다음 페이징 쿼리에서는 현재 페이지의 가장 작은 article_id 값보다 작은 article_id 만 쿼리하도록 변경했다.

```sql
SELECT *
FROM tb_article WHERE board_id = 1 AND article_id < 165; /* 이전 페이지의 가장 마지막 article_id 값 */
ORDER BY article_id DESC LIMIT 0, 20;
```

위의 페이징 쿼리 처럼 "article_id < 165" 조건을 추가하면 MySQL 서버는 board_id 가 1 인 레코드에 대해 article_id 가 312 부터 165 인 레코드까지는 전혀 읽지 않고 그냥 건너뛰게 된다. 그리고 게시물 번호가 163 인 레코드 부터 20 개만 읽어서 반환한다.

아주 간단한 내용이지만 자주 사용되는 쿼리라면 디스크의 일기 부하를 상당량 줄일 수 있다.

> 프라이머리 키가 클러스터링 키인 InnoDB 테이블에서는 board_id 컬럼만으로 인덱스를 생성하면 자동적으로 프라이머리 키인 article_id 가 인덱스의 마지막 컬럼으로 추가된다.

다음 예제와 같이 페이징 쿼리의 검색 조건에서 LIKE 나 IN 또는 BETWEEN 과 같은 범위 조건이 사용될 때 주의해야 한다.

ORDER BY 절에서 사용된 컬럼과 WHERE 절의 범위 조건에 사용된 컬럼이 서로 다른 쿼리는 인덱스를 어떻게 만들든 검색과 정렬 작업 모두 인덱스를 이용하는 것이 불가능하다.
예를 들어, (board_id, article_status, article_id) 로 인덱스가 만들어져 있는 상태에서 다음 쿼리에 article_id 를 페이징 쿼리의 조건에 추가하면 잘못된 결과를 낼 수 있다.

```sql
SELECT * 
FROM tb_article
WHERE board_id = 1
AND article_status IN ('A', 'B')
ORDER BY article_id
DESC LIMIT 0, 20;
```

## count 쿼리

LIMIT 의 오프셋(offset) 을 설정하기 위해서 게시물 총 개수를 가져와서 계산하여 넣어주는 과정이 필요한데, 총 개수를 구하는 count 쿼리는
사실 한 번만 동작하면된다. 즉, 첫 페이지에 진입할 시점에만 동작하게하고, 그 결과를 JSP 에서 hidden 으로 가지고 있는 상태로 2 페이지 진입할 때
서버로 값을 넘겨주기만 하면 불필요한 count 쿼리 호출을 막을 수 있다.

